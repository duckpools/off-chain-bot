{
	val collateralBoxScript  = fromBase58("J9oDdsJT4nWB2QX9s7h8jHQH42z97sW56626t2cHPzLi")
	val minTxFee      = 1000000L
	val minBoxValue   = 1000000L
	val poolNFT       = fromBase58("6oK2yuvjnYiTSZAuwk2hvbWNRcsatsnpPoyqs3ZG8ja6")
 	val BorrowTokenId = fromBase58("9aT2hsbH79ropV2quz8mdsv2ppJWfc75F9gHZR8x4K7Z")
	val PoolNativeCurrency = fromBase58("2YLqN97ELrd12QLszzTVF6wXPYMegNtmdNsnaG51fcHN")
	
	val user = SELF.R4[Coll[Byte]].get
	val userPk = SELF.R5[GroupElement].get
	val publicRefund  = SELF.R6[Int].get
	val requestAmounts = SELF.R7[Coll[Long]].get
	val userQuoteNFT = SELF.R8[Coll[Byte]].get
	val userSpendingNFT = SELF.R9[Coll[Byte]].get
	
	val operation = if (OUTPUTS.size < 3) {
		val refundBox = OUTPUTS(0)
		val deltaErg = SELF.value - refundBox.value
		
		val validRefundRecipient = refundBox.propositionBytes == user
		val multiBoxSpendRefund = refundBox.R4[Coll[Byte]].get == SELF.id
		val validDeltaErg = deltaErg <= minTxFee
		val validHeight   = HEIGHT >= publicRefund		
		
		val refund = (
			validRefundRecipient  &&
			validDeltaErg &&
			multiBoxSpendRefund &&
			validHeight 
		)
		refund	
	} else {
		val poolBox       = OUTPUTS(0)
		val collateralBox = OUTPUTS(1)
		val userBox       = OUTPUTS(2)
		
		val collateralTokens = collateralBox.tokens
		val collateral = collateralBox.value
		val collateralBorrowTokens = collateralBox.tokens(0)
		val recordedBorrower = collateralBox.R4[Coll[Byte]].get
		val recordedBorrowerPK = collateralBox.R5[GroupElement].get
		val bufferLiquidation = collateralBox.R6[Long].get
		val quoteNFT = collateralBox.R7[Coll[Byte]].get
		val spendingNFT = collateralBox.R8[Coll[Byte]].get
		
		val loanAmount = collateralBorrowTokens._2
		
		val validCollateralBoxScript = blake2b256(collateralBox.propositionBytes) == collateralBoxScript
		val validCollateralTokens = collateral == SELF.value - minBoxValue - minTxFee
		val validLoanAmount = (
			requestAmounts(1) >= collateralBorrowTokens._2 &&
			collateralBorrowTokens._1 == BorrowTokenId &&
			userBox.tokens(0)._1 == PoolNativeCurrency
			)
		
		val validBorrower = collateralBox.R4[Coll[Byte]].get == user
		val validUserPk = userPk == recordedBorrowerPK
		val validQuoteNFT = userQuoteNFT == quoteNFT
		val validSpendingNFT = userSpendingNFT == spendingNFT
		
		val validBorrow = INPUTS(0).tokens(0)._1 == poolNFT
		
		val validUserScript = userBox.propositionBytes == user
		val validUserLoanAmount = userBox.tokens(0)._2 == requestAmounts(0)
		val multiBoxSpendSafety = userBox.R4[Coll[Byte]].get == SELF.id
		
		val exchange = (
			validCollateralBoxScript &&
			validUserScript &&
			validCollateralTokens &&
			validLoanAmount &&
			validBorrower &&
			validUserPk &&
			validQuoteNFT &&
			validSpendingNFT &&
			validBorrow &&
			validUserLoanAmount && 
			multiBoxSpendSafety
		)
		exchange
	}
	operation || proveDlog(userPk)
}


{
	// Constants
	val MinTxFee = 1000000L
	
	// Extract values from SELF
	val partialRepayment = SELF.tokens(0)._2
	val collateralBoxId = SELF.R4[Coll[Byte]].get
	val finalBorrowTokens = SELF.R5[Long].get
	val userScript = SELF.R6[Coll[Byte]].get
	val refundHeight = SELF.R7[Long].get
	
	sigmaProp(if (OUTPUTS.size <= 2) {
		// Refunds		
		val refundBox = OUTPUTS(0)
		
		val validBorrowerScript = refundBox.propositionBytes == userScript
		val validRefundValue = refundBox.value >= SELF.value - MinTxFee
		val validTokensRefunded = refundBox.tokens == SELF.tokens
		
		val refund = (
			validBorrowerScript &&
			validRefundValue &&
			validTokensRefunded &&
			HEIGHT >= refundHeight
		)
		refund
	} else {
		// Partial Repayment
		// Extract values from collateral box
		val currentCollateralBox = INPUTS(1)
		val currentScript = currentCollateralBox.propositionBytes
		val currentValue = currentCollateralBox.value
		val currentBorrowTokens = currentCollateralBox.tokens(0)
		val currentBorrower = currentCollateralBox.R4[Coll[Byte]].get
		val currentUserPk = currentCollateralBox.R5[GroupElement].get
		val iBufferLiquidation = currentCollateralBox.R6[Long].get
		val currentQuoteNFT = currentCollateralBox.R7[Coll[Byte]].get
		val iSpendingNFT = currentCollateralBox.R8[Coll[Byte]].get
    val iLoanSettings = currentCollateralBox.R9[Coll[Long]].get
		val currentLoanAmount = currentBorrowTokens._2

		// Extract values from final collateral box
		val successorCollateralBox = OUTPUTS(0)
		val successorScript = successorCollateralBox.propositionBytes
		val successorValue = successorCollateralBox.value
		val successorBorrowTokens = successorCollateralBox.tokens(0)
		val fCollateralBorrower = successorCollateralBox.R4[Coll[Byte]].get
		val fCollateralUserPk = successorCollateralBox.R5[GroupElement].get
		val fBufferLiquidation = successorCollateralBox.R6[Long].get
		val fCollateralQuoteNFT = successorCollateralBox.R7[Coll[Byte]].get
		val fSpendingNFT = successorCollateralBox.R8[Coll[Byte]].get
    val fLoanSettings = successorCollateralBox.R9[Coll[Long]].get

		// Validate the current collateral box
		val validInputCollateral = currentCollateralBox.id == collateralBoxId

		// Validate the successor collateral box
		// Validate successor collateral box
		val validSuccessorScript = successorScript == currentScript
		val retainMinValue = successorValue >= currentValue
		val retainBorrowTokenId = successorBorrowTokens._1 == currentBorrowTokens._1
		val validBorrowTokens = successorBorrowTokens._2 <= finalBorrowTokens
		val retainRegisters = (
			currentBorrower == fCollateralBorrower &&
			currentUserPk == fCollateralUserPk &&
			iBufferLiquidation == fBufferLiquidation &&
			currentQuoteNFT == fCollateralQuoteNFT &&
			iSpendingNFT == fSpendingNFT &&
      iLoanSettings == fLoanSettings
		)
		
		val isPartialRepayment = (
			validSuccessorScript &&
			validInputCollateral &&
			retainMinValue &&
			retainBorrowTokenId &&
			validBorrowTokens &&
			retainRegisters 
		)
		isPartialRepayment
	})
}
